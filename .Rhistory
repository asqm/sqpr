vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in `df`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
# Check all variables present in sqp_data
vars_not_matched <- !vars_names %in% sqp_data[[1]]
if (any(vars_not_matched)) {
stop("One or more variables are not present in `sqp_data`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
the_vars <- df[vars_names]
# Check all variables are numeric and there are at least two columns in the df data
if (!all(purrr::map_lgl(the_vars, is.numeric))) {
stop(paste0(vars_names, collapse = ", "), " must be numeric variables in `df`")
}
if (ncol(the_vars) < 2) stop("`df` must have at least two columns")
# Check SQP data has correct class and formats
check_sqp_data(sqp_data)
# Select the rows with only the selected variales
# for the sumscore
rows_to_pick <- sqp_data[[1]] %in% vars_names
sqp_scores <- sqp_data[rows_to_pick, 2, drop = TRUE]
new_estimate <-
columns_sqp("quality", estimate_sscore(sqp_scores, the_vars, vars_names))
additional_rows <- generic_sqp(summary_name, new_estimate)
# Bind the unselected questions with the new sumscore
combined_matrix <- dplyr::bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
structure(combined_matrix, class = c(class(combined_matrix), "sqp"))
}
# This is not supposed to be used in isolation.
# Rather with measurement quality as a wrapper
# because it checks all of the arguments are in
# the correct format, etc..
estimate_sscore <- function(sqp_data, df, vars_names) {
# Calculate the sum score and it's variance
var_sumscore <- stats::var(rowSums(df, na.rm = TRUE), na.rm = TRUE)
# Calculat variable of each of the selected variables
var_othervars <- purrr::map_dbl(df, stats::var, na.rm = TRUE)
# Each sqp score is subtracted a 1 and multiplied
# by it's corresponding var_* variables
adj_sqp <- (1 - sqp_data) *  var_othervars
# This new vector is summed and divided by the variance of the sumscore
# and 1 is subtracted from the final result
final_result <- 1 - sum(adj_sqp) / var_sumscore
final_result
}
# Check the SQP data
check_sqp_data <- function(sqp_data) {
stopifnot(is.data.frame(sqp_data))
first_character <- is.character(sqp_data[[1]])
all_numeric <- all(purrr::map_lgl(sqp_data[-1], is.numeric))
# Check all variables are numeric in the sqp data
if(!first_character | !all_numeric) {
stop("`sqp_data` must be collected using sqp_collect()",
call. = FALSE)
}
}
expect_error(
sqp_sscore(
sqp_data = tmp_sqp,
df = sample_data,
new_name = new_sumscore,
V1, V5),
"`sqp_data` must be collected using sqp_collect()"
)
#' "V1", "V2", "V3"
#' )
#'
#' sqp_sscore(
#' sqp_data = sqp_df,
#' df = sample_data,
#' new_name = new_sumscore,
#' V1, random_var
#' )
#'
sqp_sscore <- function(sqp_data, df, new_name, ...) {
if (!inherits(sqp_data, "sqp")) {
stop("`sqp_data` must be collected using sqp_collect()",
call. = FALSE)
}
# Turn all variables into a list and delete the 'list'
# from the new character vector
vars_names <- as.character(substitute(list(...)))[-1]
summary_name <- as.character(substitute(new_name))
# Check all variables present in df
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in `df`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
# Check all variables present in sqp_data
vars_not_matched <- !vars_names %in% sqp_data[[1]]
if (any(vars_not_matched)) {
stop("One or more variables are not present in `sqp_data`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
the_vars <- df[vars_names]
# Check all variables are numeric and there are at least two columns in the df data
if (!all(purrr::map_lgl(the_vars, is.numeric))) {
stop(paste0(vars_names, collapse = ", "), " must be numeric variables in `df`")
}
if (ncol(the_vars) < 2) stop("`df` must have at least two columns")
# Check SQP data has correct class and formats
check_sqp_data(sqp_data)
# Select the rows with only the selected variales
# for the sumscore
rows_to_pick <- sqp_data[[1]] %in% vars_names
sqp_scores <- sqp_data[rows_to_pick, 2, drop = TRUE]
new_estimate <-
columns_sqp("quality", estimate_sscore(sqp_scores, the_vars, vars_names))
additional_rows <- generic_sqp(summary_name, new_estimate)
# Bind the unselected questions with the new sumscore
combined_matrix <- dplyr::bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
structure(combined_matrix, class = c(class(combined_matrix), "sqp"))
}
expect_error(
sqp_sscore(
sqp_data = mtcars,
df = sample_data,
new_name = new_sumscore,
V1, V2),
regexp = "`sqp_data` must be collected using sqp_collect()"
)
expect_error(
sqp_sscore(
sqp_data = mtcars,
df = sample_data,
new_name = new_sumscore,
V1, V2),
"`sqp_data` must be collected using sqp_collect()"
)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:5))
)
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
result
result[4, 1, drop = TRUE]
result[4, 2, drop = TRUE]
expect_equal(result[4, 2, drop = TRUE], 0.5531289)
expect_identical(result[4, 2, drop = TRUE], 0.5531289)
?expect_equivalent
expect_equal(result[4, 2, drop = TRUE], 0.5531289)
result[4, 2, drop = TRUE]
round(result[4, 2, drop = TRUE], 3)
expect_equal(round(result[4, 2, drop = TRUE], 3), 0.553)
devtools::document()
devtools::check()
set.seed(231321)
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:5))
)
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
round(result[4, 2, drop = TRUE], 3)
expect_equal(round(result[4, 2, drop = TRUE], 3), 0.563)
devtools::check()
library(testthat)
devtools::load_all()
context("test-sqp_sscore.R")
set.seed(231321)
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:5))
)
test_that("sqp_sscore returns correct output", {
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
expect_s3_class(result, "data.frame")
expect_s3_class(result, "sqp")
expect_equal(nrow(result), 4)
expect_equal(nrow(result), ncol(result))
expect_is(result[[1]], "character")
# Same result:
expect_equal(round(result[4, 2, drop = TRUE], 3), 0.563)
})
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8),
random_var = NA_real_)
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(6, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:6))
)
test_that("sqp_sscore checks for arguments", {
expect_error(
sqp_sscore(
sqp_data = mtcars,
df = sample_data,
new_name = new_sumscore,
V1, V2),
"`sqp_data` must be collected using sqp_collect()"
)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore),
"`df` must have at least two columns"
)
tmp <- sample_data
tmp$V5 <- as.character(tmp$V5)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = tmp,
new_name = new_sumscore,
V1, V5),
"V1, V5 must be numeric variables in `df`"
)
tmp_sqp <- sqp_df
tmp_sqp$quality <- as.character(tmp_sqp$quality)
expect_error(
sqp_sscore(
sqp_data = tmp_sqp,
df = sample_data,
new_name = new_sumscore,
V1, V5),
"`sqp_data` must be collected using sqp_collect()"
)
})
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V1, random_var)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V1, random_var),
"One or more variables are not present in `df`: random_var"
)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V1, V6),
"One or more variables are not present in `sqp_data`: V6"
)
devtools::load_all()
library(testthat)
context("test-sqp_sscore.R")
set.seed(231321)
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:5))
)
test_that("sqp_sscore returns correct output", {
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
expect_s3_class(result, "data.frame")
expect_s3_class(result, "sqp")
expect_equal(nrow(result), 4)
expect_equal(nrow(result), ncol(result))
expect_is(result[[1]], "character")
# Same result:
expect_equal(round(result[4, 2, drop = TRUE], 3), 0.563)
})
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8),
random_var = NA_real_)
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(6, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:6))
)
test_that("sqp_sscore checks for arguments", {
expect_error(
sqp_sscore(
sqp_data = mtcars,
df = sample_data,
new_name = new_sumscore,
V1, V2),
"`sqp_data` must be collected using sqp_collect()"
)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore),
"`df` must have at least two columns"
)
tmp <- sample_data
tmp$V5 <- as.character(tmp$V5)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = tmp,
new_name = new_sumscore,
V1, V5),
"V1, V5 must be numeric variables in `df`"
)
tmp_sqp <- sqp_df
tmp_sqp$quality <- as.character(tmp_sqp$quality)
expect_error(
sqp_sscore(
sqp_data = tmp_sqp,
df = sample_data,
new_name = new_sumscore,
V1, V5),
"`sqp_data` must be collected using sqp_collect()"
)
})
test_that("sqp_sscore checks variables are in both dfs", {
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V1, random_var),
"One or more variables are not present in `df`: random_var"
)
expect_error(
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V1, V6),
"One or more variables are not present in `sqp_data`: V6"
)
})
devtools::check()
devtools::check()
check_da
check_sqp_data
# Check the SQP data
check_sqp_data <- function(sqp_data) {
stopifnot(is.data.frame(sqp_data))
if (!inherits(sqp_data, "sqp")) {
stop("`sqp_data` must be collected using sqp_collect()",
call. = FALSE)
}
first_character <- is.character(sqp_data[[1]])
all_numeric <- all(purrr::map_lgl(sqp_data[-1], is.numeric))
# Check all variables are numeric in the sqp data
if(!first_character | !all_numeric) {
stop("`sqp_data` must be collected using sqp_collect()",
call. = FALSE)
}
}
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::document()
devtools::document()
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sqp_df
sqp_bind_metrics(sqp_df, new_question, list(quality = 0.7))
sqp_bind_metrics(sqp_df, new_question, list(quality = 0.7, reliability = 0.2))
sqp_bind_metrics(sqp_df, new_question, list(wrong_metric = 0.7))
devtools::check()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
load_all()
devtools::load_all()
?sqpr::construct_sqp
devtools::load_all()
?construct_sqp
devtools::document()
devtools::check()
?construct_sqp
devtools::load_all()
?construct_sqp
devtools::load_al()
devtools::load_all()
?construct_sqp
?construct_sqp_
?construct_sqp_()
devtools::load_all()
?construct_sqp
devtools::load_all()
?construct_sqp
?select_all
?dplyr::select_all
?construct_sqo
?construct_sqp
devtools::load_all()
?construct_sqp
construct_sqp(new_question, list(quality = 0.3))
#' construct_sqp(new_question, list(quality = 0.3, validity = 0.2))
#'
#' # Note that specifying a column which is not availabe in SQP data
#' # will throw an error
#'
#' # construct_sqp(new_question, list(random_col = 0.3, validity = 0.2))
#' # Error: One or more of the specified metrics don't match the SQP column names
#'
#' # Currently only quality, reliability and validity are allowed.
#'
construct_sqp <- function(question_name, metrics) {
question <- as.character(substitute(question_name))
construct_sqp_(question, metrics)
}
construct_sqp(new_question, list(quality = 0.3))
#' @rdname sqp_construct
#' @export
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("`question_name` must have only one question",
call. = FALSE)
is_list <- is.list(metrics)
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric | !is_list) {
stop("`metrics` must be a named numeric list",
call. = FALSE)
}
if (length(names(metrics)) != length(unlist(metrics))) {
stop("`metrics` must contain only one element per name",
call. = FALSE)
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
construct_sqp(new_question, list(quality = 0.3))
construct_sqp(new_question, list(random_col = 0.3, validity = 0.2))
devtools::load_all()
?construct_sqp
devtools::test()
devtools::test()
devtools::document()
devtools::document()
devtools::test()
devtools::check()
devtools::check()
