expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = as.matrix(original_data)),
"is.data.frame(.*) is not TRUE")
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = as.matrix(original_data)),
"is.data.frame(.*) is not TRUE")
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE),
"Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = mtcars)
?stopifnot
!cmv_vars %in% names(original_data))
!cmv_vars %in% names(original_data)
!all(cmv_vars %in% names(original_data))
all(cmv_vars %in% names(original_data))
original_data
#' # The V5*V4 from both the upper/lower triangles
#' # correlation matrix changed from -0.05 to -0.203
#'
#' # If you want to get a standardized CMV, then supply
#' # `standardized = TRUE` and `original_data`.
#'
#' sqp_cmv(corr_tibble, sqp_df, V4, V5,
#'         standardized = TRUE,
#'         original_data = original_df)
#'
sqp_cmv <- function(x, sqp_data, ..., standardized = FALSE, original_data, cmv = NULL) {
cmv_vars <- unique(as.character(substitute(list(...)))[-1])
if (!(is.data.frame(x) | is.matrix(x))) {
stop("`x` must be a correlation data frame or matrix")
}
if (length(cmv_vars) < 2) {
stop("You need to supply at least two variables to calculate the Common Method Variance",
call. = FALSE)
}
sqp_data <- sqp_reconstruct(sqp_data, c("reliability", "validity"))
x <- matrix2tibble(x)
# Check if all supplied variables are present in both
# dfs
columns_present(x, sqp_data, cmv_vars)
selected_rows <- sqp_data[[1]] %in% cmv_vars
if (is.null(cmv)) cmv <- estimate_cmv(sqp_data[selected_rows, ])
# Check that if standardized is TRUE and original data is there
if (standardized && missing(original_data)) {
stop("Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
} else if (standardized && !missing(original_data)) {
# If both args are there, check that it's a data frame and that all variables are there
stopifnot(is.data.frame(original_data))
if (!all(cmv_vars %in% names(original_data))) {
stop("Variables", cmv_vars[!cmv_vars %in% names(original_data))], "are not preset in `original_data`"
}
# Calculate standardized cmv
cmv <- prod(cmv, vapply(original_data[cmv_vars], sd, FUN.VALUE = numeric(1)))
}
corrected_corr <- tibble::as_tibble(corr2cmv(x, cmv, cmv_vars))
corrected_corr
}
#' # The V5*V4 from both the upper/lower triangles
#' # correlation matrix changed from -0.05 to -0.203
#'
#' # If you want to get a standardized CMV, then supply
#' # `standardized = TRUE` and `original_data`.
#'
#' sqp_cmv(corr_tibble, sqp_df, V4, V5,
#'         standardized = TRUE,
#'         original_data = original_df)
#'
sqp_cmv <- function(x, sqp_data, ..., standardized = FALSE, original_data, cmv = NULL) {
cmv_vars <- unique(as.character(substitute(list(...)))[-1])
if (!(is.data.frame(x) | is.matrix(x))) {
stop("`x` must be a correlation data frame or matrix")
}
if (length(cmv_vars) < 2) {
stop("You need to supply at least two variables to calculate the Common Method Variance",
call. = FALSE)
}
sqp_data <- sqp_reconstruct(sqp_data, c("reliability", "validity"))
x <- matrix2tibble(x)
# Check if all supplied variables are present in both
# dfs
columns_present(x, sqp_data, cmv_vars)
selected_rows <- sqp_data[[1]] %in% cmv_vars
if (is.null(cmv)) cmv <- estimate_cmv(sqp_data[selected_rows, ])
# Check that if standardized is TRUE and original data is there
if (standardized && missing(original_data)) {
stop("Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
} else if (standardized && !missing(original_data)) {
# If both args are there, check that it's a data frame and that all variables are there
stopifnot(is.data.frame(original_data))
if (!all(cmv_vars %in% names(original_data))) {
stop("Variables", cmv_vars[!cmv_vars %in% names(original_data)], "are not preset in `original_data`")
}
# Calculate standardized cmv
cmv <- prod(cmv, vapply(original_data[cmv_vars], sd, FUN.VALUE = numeric(1)))
}
corrected_corr <- tibble::as_tibble(corr2cmv(x, cmv, cmv_vars))
corrected_corr
}
devtools::load_all()
library(testthat)
context("test-sqp_cmv.R")
set.seed(2131)
suppressWarnings(library(tibble))
original_df <- as.data.frame(matrix(rnorm(100, sd = 50), nrow = 20))
corr_tibble <-
sqp_correlate(original_df,
rnorm(5))
# test missing:
# When y is not from sqp_collect(), sqp_cmv must throw an error
# Show that when y is not from sqp class, there's an error
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
correct_format <- function(p) {
expect_is(p, "data.frame")
expect_equal(names(p)[[1]], "rowname")
# First column is the row names
expect_is(p[[1]], "character")
# All other columns are numeric
expect_true(all(vapply(p[-1], is.numeric, FUN.VALUE = logical(1))))
# All row names have a at least one letter, which means
# that the row names were not extracted raw if `x`
# was a matrix
expect_true(all(grepl("[[:alpha:]]{1,}", p[[1]])))
# df is symmetric when excluding the rowname variables
expect_equal(nrow(p), ncol(p) - 1)
invisible(TRUE)
}
test_that("sqp_cmv returns correct output", {
cmv_tib <- sqp_cmv(corr_tibble, sqp_df, V4, V5)
correct_format(cmv_tib)
# Also handles character strings as variables
expect_identical(cmv_tib,
sqp_cmv(corr_tibble, sqp_df, "V4", "V5"))
})
test_that("`x` argument works fine with matrix", {
random_vec <- rnorm(10, sd = 50)
matr_nothing <- matrix(random_vec, 5, 5)
matr_row <- matrix(random_vec, 5, 5,
dimnames = list(paste0("V", seq_len(5))))
matr_col <- matrix(random_vec, 5, 5,
dimnames = list(NULL, paste0("V", seq_len(5))))
matr_both <- matrix(random_vec, 5, 5,
dimnames = list(paste0("V", seq_len(5)),
paste0("V", seq_len(5))))
# Matrix no row or col names
cmv_matr <- sqp_cmv(matr_nothing, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix row names
cmv_matr <- sqp_cmv(matr_row, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix col names
cmv_matr <- sqp_cmv(matr_col, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix row and col names
cmv_matr <- sqp_cmv(matr_both, sqp_df, V4, V5)
correct_format(cmv_matr)
})
test_that("`x` argument works fine with data frame", {
random_vec <- rnorm(10, sd = 50)
df_no_rows <- as.data.frame(matrix(random_vec, 5, 5))
# df no row names
cmv_matr <- sqp_cmv(df_no_rows, sqp_df, V4, V5)
correct_format(cmv_matr)
rownames(df_no_rows) <- paste0("V", seq_len(5))
df_rows <- df_no_rows
# df row names
cmv_matr <- sqp_cmv(df_rows, sqp_df, V4, V5)
correct_format(cmv_matr)
})
test_that("sqp_cmv works with cmv argument", {
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.6, 0.4, 0.5, 0.5, 0.7),
validity = c(0.9, 0.5, 0.6, 0.7, 0.8))
filtered_df <- subset(sqp_df, question %in% c("V4", "V5"))
cmv_aut <- sqp_cmv(corr_tibble, sqp_df, V4, V5)
cmv_manual <- sqp_cmv(corr_tibble, sqp_df, V4, V5, cmv = estimate_cmv(filtered_df))
expect_equal(cmv_aut, cmv_manual)
})
test_that("sqp_cmv uses only unique variable names", {
cmv_tib <- sqp_cmv(corr_tibble, sqp_df, V4, V5, V5)
expect_is(cmv_tib, "data.frame")
# First column is the row names
expect_is(cmv_tib[[1]], "character")
# All other columns are numeric
expect_true(all(vapply(cmv_tib[-1], is.numeric, FUN.VALUE = logical(1))))
# df is symmetric when excluding the rowname variables
expect_equal(nrow(cmv_tib), ncol(cmv_tib) - 1)
})
test_that("sqp_cmv throws specific errors", {
expect_error(sqp_cmv(list(), sqp_df),
"`x` must be a correlation data frame or matrix")
expect_error(sqp_cmv(corr_tibble, sqp_df),
"You need to supply at least two variables to calculate the Common Method Variance")
expect_error(sqp_cmv(corr_tibble, sqp_df, V2),
"You need to supply at least two variables to calculate the Common Method Variance")
expect_error(sqp_cmv(corr_tibble, sqp_df, V2, V3),
"`sqp_data` must have non-missing values at columns reliability and validity for all variables")
expect_error(sqp_cmv(corr_tibble, sqp_df, hey, other),
"At least one variable not present in `x`: hey, other")
})
test_that("sqp_cmv replaces upper and lower triangle", {
up_equal <- function(x) {
tp <- x[-1]
all(sort(tp[lower.tri(tp)]) == sort(tp[upper.tri(tp)]))
}
# Two variables
cmv_tib <- as.data.frame(sqp_cmv(corr_tibble, sqp_df, V4, V5))
expect_true(up_equal(cmv_tib))
# Three variables
cmv_tib <- as.data.frame(sqp_cmv(corr_tibble, sqp_df, V3, V4, V5))
expect_true(up_equal(cmv_tib))
})
test_that("sqp_sscore adds sqp class to valid sqp_data", {
tmp <- sqp_df
class(tmp) <- c("tbl_df", "tbl", "data.frame")
noclass <- sqp_cmv(
corr_tibble,
sqp_data = tmp,
V4, V5
)
valid_class <- sqp_cmv(
corr_tibble,
sqp_data = sqp_df,
V4, V5
)
expect_identical(valid_class, noclass)
})
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE),
"Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = as.matrix(original_data)),
"is.data.frame(.*) is not TRUE")
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = as.matrix(original_df)),
"is.data.frame(.*) is not TRUE")
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = mtcars)
#' # The V5*V4 from both the upper/lower triangles
#' # correlation matrix changed from -0.05 to -0.203
#'
#' # If you want to get a standardized CMV, then supply
#' # `standardized = TRUE` and `original_data`.
#'
#' sqp_cmv(corr_tibble, sqp_df, V4, V5,
#'         standardized = TRUE,
#'         original_data = original_df)
#'
sqp_cmv <- function(x, sqp_data, ..., standardized = FALSE, original_data, cmv = NULL) {
cmv_vars <- unique(as.character(substitute(list(...)))[-1])
if (!(is.data.frame(x) | is.matrix(x))) {
stop("`x` must be a correlation data frame or matrix")
}
if (length(cmv_vars) < 2) {
stop("You need to supply at least two variables to calculate the Common Method Variance",
call. = FALSE)
}
sqp_data <- sqp_reconstruct(sqp_data, c("reliability", "validity"))
x <- matrix2tibble(x)
# Check if all supplied variables are present in both
# dfs
columns_present(x, sqp_data, cmv_vars)
selected_rows <- sqp_data[[1]] %in% cmv_vars
if (is.null(cmv)) cmv <- estimate_cmv(sqp_data[selected_rows, ])
# Check that if standardized is TRUE and original data is there
if (standardized && missing(original_data)) {
stop("Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
} else if (standardized && !missing(original_data)) {
# If both args are there, check that it's a data frame and that all variables are there
stopifnot(is.data.frame(original_data))
if (!all(cmv_vars %in% names(original_data))) {
stop("Variables ",
paste(cmv_vars[!cmv_vars %in% names(original_data)], sep = ", "),
"are not preset in `original_data`")
}
# Calculate standardized cmv
cmv <- prod(cmv, vapply(original_data[cmv_vars], sd, FUN.VALUE = numeric(1)))
}
corrected_corr <- tibble::as_tibble(corr2cmv(x, cmv, cmv_vars))
corrected_corr
}
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = mtcars)
#' # The V5*V4 from both the upper/lower triangles
#' # correlation matrix changed from -0.05 to -0.203
#'
#' # If you want to get a standardized CMV, then supply
#' # `standardized = TRUE` and `original_data`.
#'
#' sqp_cmv(corr_tibble, sqp_df, V4, V5,
#'         standardized = TRUE,
#'         original_data = original_df)
#'
sqp_cmv <- function(x, sqp_data, ..., standardized = FALSE, original_data, cmv = NULL) {
cmv_vars <- unique(as.character(substitute(list(...)))[-1])
if (!(is.data.frame(x) | is.matrix(x))) {
stop("`x` must be a correlation data frame or matrix")
}
if (length(cmv_vars) < 2) {
stop("You need to supply at least two variables to calculate the Common Method Variance",
call. = FALSE)
}
sqp_data <- sqp_reconstruct(sqp_data, c("reliability", "validity"))
x <- matrix2tibble(x)
# Check if all supplied variables are present in both
# dfs
columns_present(x, sqp_data, cmv_vars)
selected_rows <- sqp_data[[1]] %in% cmv_vars
if (is.null(cmv)) cmv <- estimate_cmv(sqp_data[selected_rows, ])
# Check that if standardized is TRUE and original data is there
if (standardized && missing(original_data)) {
stop("Argument `standardized` was set to `TRUE` but the `original_data` argument was not supplied")
} else if (standardized && !missing(original_data)) {
# If both args are there, check that it's a data frame and that all variables are there
stopifnot(is.data.frame(original_data))
if (!all(cmv_vars %in% names(original_data))) {
stop("Variables ",
paste(cmv_vars[!cmv_vars %in% names(original_data)], collapse = ", "),
" are not preset in `original_data`")
}
# Calculate standardized cmv
cmv <- prod(cmv, vapply(original_data[cmv_vars], sd, FUN.VALUE = numeric(1)))
}
corrected_corr <- tibble::as_tibble(corr2cmv(x, cmv, cmv_vars))
corrected_corr
}
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = mtcars)
expect_error(sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = TRUE,
original_data = mtcars),
"Variables .+ are not preset in `original_data`")
sqp_cmv(corr_tibble, sqp_df, V4, V5,
standardized = TRUE,
original_data = original_df)
columns_present
Sys.setenv(SQP_USER = 'cimentadaj@gmail.com'); Sys.setenv("SQP_PW" = "Lolasouno2"); Sys.setenv("ess_email" = "cimentadaj@gmail.com")
devtools::check()
devtools::check()
Sys.setenv(SQP_USER = 'cimentadaj@gmail.com'); Sys.setenv("SQP_PW" = "Lolasouno2"); Sys.setenv("ess_email" = "cimentadaj@gmail.com")
devtools::check()
context("test-sqp_cmv.R")
set.seed(2131)
suppressWarnings(library(tibble))
original_df <- as.data.frame(matrix(rnorm(100, sd = 50), nrow = 20))
corr_tibble <-
sqp_correlate(original_df,
rnorm(5))
# test missing:
# When y is not from sqp_collect(), sqp_cmv must throw an error
# Show that when y is not from sqp class, there's an error
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(NA, 0.4, 0.5, 0.5, 0.7),
validity = c(NA, NA, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
correct_format <- function(p) {
expect_is(p, "data.frame")
expect_equal(names(p)[[1]], "rowname")
# First column is the row names
expect_is(p[[1]], "character")
# All other columns are numeric
expect_true(all(vapply(p[-1], is.numeric, FUN.VALUE = logical(1))))
# All row names have a at least one letter, which means
# that the row names were not extracted raw if `x`
# was a matrix
expect_true(all(grepl("[[:alpha:]]{1,}", p[[1]])))
# df is symmetric when excluding the rowname variables
expect_equal(nrow(p), ncol(p) - 1)
invisible(TRUE)
}
test_that("sqp_cmv returns correct output", {
cmv_tib <- sqp_cmv(corr_tibble, sqp_df, V4, V5)
correct_format(cmv_tib)
# Also handles character strings as variables
expect_identical(cmv_tib,
sqp_cmv(corr_tibble, sqp_df, "V4", "V5"))
})
test_that("`x` argument works fine with matrix", {
random_vec <- rnorm(10, sd = 50)
matr_nothing <- matrix(random_vec, 5, 5)
matr_row <- matrix(random_vec, 5, 5,
dimnames = list(paste0("V", seq_len(5))))
matr_col <- matrix(random_vec, 5, 5,
dimnames = list(NULL, paste0("V", seq_len(5))))
matr_both <- matrix(random_vec, 5, 5,
dimnames = list(paste0("V", seq_len(5)),
paste0("V", seq_len(5))))
# Matrix no row or col names
cmv_matr <- sqp_cmv(matr_nothing, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix row names
cmv_matr <- sqp_cmv(matr_row, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix col names
cmv_matr <- sqp_cmv(matr_col, sqp_df, V4, V5)
correct_format(cmv_matr)
# Matrix row and col names
cmv_matr <- sqp_cmv(matr_both, sqp_df, V4, V5)
correct_format(cmv_matr)
})
test_that("`x` argument works fine with data frame", {
random_vec <- rnorm(10, sd = 50)
df_no_rows <- as.data.frame(matrix(random_vec, 5, 5))
# df no row names
cmv_matr <- sqp_cmv(df_no_rows, sqp_df, V4, V5)
correct_format(cmv_matr)
rownames(df_no_rows) <- paste0("V", seq_len(5))
df_rows <- df_no_rows
# df row names
cmv_matr <- sqp_cmv(df_rows, sqp_df, V4, V5)
correct_format(cmv_matr)
})
test_that("sqp_cmv works with cmv argument", {
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.6, 0.4, 0.5, 0.5, 0.7),
validity = c(0.9, 0.5, 0.6, 0.7, 0.8))
filtered_df <- subset(sqp_df, question %in% c("V4", "V5"))
cmv_aut <- sqp_cmv(corr_tibble, sqp_df, V4, V5)
cmv_manual <- sqp_cmv(corr_tibble, sqp_df, V4, V5, cmv = estimate_cmv(filtered_df))
expect_equal(cmv_aut, cmv_manual)
})
test_that("sqp_cmv uses only unique variable names", {
cmv_tib <- sqp_cmv(corr_tibble, sqp_df, V4, V5, V5)
expect_is(cmv_tib, "data.frame")
# First column is the row names
expect_is(cmv_tib[[1]], "character")
# All other columns are numeric
expect_true(all(vapply(cmv_tib[-1], is.numeric, FUN.VALUE = logical(1))))
# df is symmetric when excluding the rowname variables
expect_equal(nrow(cmv_tib), ncol(cmv_tib) - 1)
})
test_that("sqp_cmv throws specific errors", {
expect_error(sqp_cmv(list(), sqp_df),
"`x` must be a correlation data frame or matrix")
expect_error(sqp_cmv(corr_tibble, sqp_df),
"You need to supply at least two variables to calculate the Common Method Variance")
expect_error(sqp_cmv(corr_tibble, sqp_df, V2),
"You need to supply at least two variables to calculate the Common Method Variance")
expect_error(sqp_cmv(corr_tibble, sqp_df, V2, V3),
"`sqp_data` must have non-missing values at columns reliability and validity for all variables")
expect_error(sqp_cmv(corr_tibble, sqp_df, hey, other),
"At least one variable not present in `x`: hey, other")
})
test_that("sqp_cmv replaces upper and lower triangle", {
up_equal <- function(x) {
tp <- x[-1]
all(sort(tp[lower.tri(tp)]) == sort(tp[upper.tri(tp)]))
}
# Two variables
cmv_tib <- as.data.frame(sqp_cmv(corr_tibble, sqp_df, V4, V5))
expect_true(up_equal(cmv_tib))
# Three variables
cmv_tib <- as.data.frame(sqp_cmv(corr_tibble, sqp_df, V3, V4, V5))
expect_true(up_equal(cmv_tib))
})
test_that("sqp_sscore adds sqp class to valid sqp_data", {
tmp <- sqp_df
class(tmp) <- c("tbl_df", "tbl", "data.frame")
noclass <- sqp_cmv(
corr_tibble,
sqp_data = tmp,
V4, V5
)
valid_class <- sqp_cmv(
corr_tibble,
sqp_data = sqp_df,
V4, V5
)
expect_identical(valid_class, noclass)
})
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = FALSE)
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = FALSE,
original_data = as.matrix(original_df))
sqp_cmv(corr_tibble,
sqp_df, V4, V5,
standardized = FALSE,
original_data = mtcars)
devtools::check()
