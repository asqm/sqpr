# Create composite scores
ess7es <-
ess7es %>%
mutate(poltrst = trstprl + trstplt + trstprt,
serv = stfedu + stfhlth,
systmrsp = psppsgv + psppipl + ptcpplt)
selected_vars <- c("trstprl", "trstplt", "trstprt",
"stfedu", "stfhlth", "psppsgv",
"psppipl", "ptcpplt", "ppltrst",
"polintr", "stflife", "stfeco",
"agea","eisced")
composite_scores <- c("poltrst", "serv", "systmrsp")
all_vars <- c(composite_scores, selected_vars) # for using later
sqp_login()
study_id <- find_studies("ESS Round 7")$id
questions <-
study_id %>%
find_questions(selected_vars[1:12]) %>%
filter(country_iso == "ES", language_iso == "spa")
all(tolower(questions$short_name) %in% selected_vars[1:12])
sqp_data <-
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
c("hey", "ho", "hey")
unique(c("hey", "ho", "hey"))
devtools::load_all()
# To preserve consistency I place the sqp vars in front
# and grab the unique columns to delete the same variables
# that are in the middle.
cols_to_pick <- unique(
c(sqp_env$short_estimate_variables, names(raw_data))
} else  {
sqp_env$short_estimate_variables
}
final_df <- raw_data[row_to_pick, cols_to_pick]
final_df <- purrr::set_names(final_df, ~ gsub("prediction.", "", .x))
final_df <- tibble::add_column(final_df, question = var_name, .before = 1)
final_df
}
devtools::load_all()
devtools::load_all()
make_estimate_df <- function(raw_data, var_name, id, all_columns = FALSE, authorized = TRUE) {
# If empty estimates..
if (all(c(1, 1) == dim(raw_data))) {
sqp_data <-
sqp_construct_(var_name,
metrics = list(quality = NA_integer_), # random metric
all_columns)
# only for all columns, bc otherwise
# you the 4 column layout of sqp of
# short columns is lost
if (all_columns) sqp_data$question_id <- id
return(sqp_data)
}
valid_rows <- !is.na(raw_data$authorized)
if (!any(valid_rows)) stop("No valid predictions for", " `", var_name,"`")
raw_data <- raw_data[valid_rows, ]
# If two authorized predictions
# are added, always returns the first one
# in order
if (authorized) {
row_to_pick <- ifelse(any(raw_data$authorized),
which(raw_data$authorized), 1)
} else {
row_to_pick <- seq_len(nrow(raw_data))
}
if (all_columns) {
# To preserve consistency I place the sqp vars in front
# and grab the unique columns to delete the same variables
# that are in the middle.
cols_to_pick <-
unique(c(sqp_env$short_estimate_variables, names(raw_data))
} else {
cols_to_pick <- sqp_env$short_estimate_variables
}
final_df <- raw_data[row_to_pick, cols_to_pick]
final_df <- purrr::set_names(final_df, ~ gsub("prediction.", "", .x))
final_df <- tibble::add_column(final_df, question = var_name, .before = 1)
final_df
}
devtools::load_all()
sqp_login()
study_id <- find_studies("ESS Round 7")$id
questions <-
study_id %>%
find_questions(selected_vars[1:12]) %>%
filter(country_iso == "ES", language_iso == "spa")
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
get_estimates(questions$id) %>%
arrange(question)
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
get_estimates(questions$id, all_columns = TRUE, authorized = FALSE) %>%
arrange(question)
devtools::load_all()
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
sqp_login()
study_id <- find_studies("ESS Round 7")$id
questions <-
study_id %>%
find_questions(selected_vars[1:12]) %>%
filter(country_iso == "ES", language_iso == "spa")
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
get_estimates(questions$id, all_columns = TRUE, authorized = TRUE) %>%
arrange(question)
get_estimates(questions$id, all_columns = TRUE, authorized = FALSE) %>%
arrange(question)
!authorized
authorized = TRUE
!authorized
#' get_estimates(c(1, 2, 86), all_columns = TRUE)
#'
#' # Explore variable names
#'
#' get_question_name(1)
#'
#' get_question_name(1:10)
#'
#' }
#'
get_estimates <- function(id, all_columns = FALSE, authorized = TRUE) {
stopifnot(is.numeric(id), length(id) >= 1)
if (length(id) > 100) {
stop("The SQP API only accepts 100 requests per call and `id` has length greater than 100")
}
collapsed_id <- paste0(id, collapse = ",")
url_id <- paste0(sqp_env$questions, collapsed_id, sqp_env$q_estimates)
q_name <- get_question_name(id)
raw_data <- object_request(url_id, estimates = TRUE)
list_data <- purrr::pmap(list(raw_data, q_name, id),
make_estimate_df,
all_columns = all_columns,
authorized = authorized)
if (!authorized) message("Authorized was set to FALSE, remember to pick only one single estimate for all variables")
final_df <- tibble::as_tibble(do.call(rbind, list_data))
final_df <- sqp_reconstruct(final_df)
final_df
}
get_estimates(questions$id, all_columns = TRUE, authorized = TRUE) %>%
arrange(question)
questions <-
study_id %>%
find_questions(selected_vars[1:12]) %>%
filter(country_iso == "ES", language_iso == "spa")
get_estimates(questions$id, all_columns = TRUE, authorized = FALSE) %>%
arrange(question)
#' @rdname get_estimates
#' @export
get_question_name <- function(id) {
stopifnot(is.numeric(id), length(id) >= 1)
collapsed_id <- paste0(id, collapse = ",")
almost_q_name <-
httr::content(
safe_GET(paste0(sqp_env$questions, collapsed_id)), as = "text"
)
q_name <- tolower(jsonlite::fromJSON(almost_q_name)$short_name)
q_name
}
make_estimate_df <- function(raw_data, var_name, id, all_columns = FALSE, authorized = TRUE) {
# If empty estimates..
if (all(c(1, 1) == dim(raw_data))) {
sqp_data <-
sqp_construct_(var_name,
metrics = list(quality = NA_integer_), # random metric
all_columns)
# only for all columns, bc otherwise
# you the 4 column layout of sqp of
# short columns is lost
if (all_columns) sqp_data$question_id <- id
return(sqp_data)
}
valid_rows <- !is.na(raw_data$authorized)
if (!any(valid_rows)) stop("No valid predictions for", " `", var_name,"`")
raw_data <- raw_data[valid_rows, ]
# If two authorized predictions
# are added, always returns the first one
# in order
if (authorized) {
row_to_pick <- ifelse(any(raw_data$authorized),
which(raw_data$authorized), 1)
} else {
row_to_pick <- seq_len(nrow(raw_data))
}
if (all_columns) {
# To preserve consistency I place the sqp vars in front
# and grab the unique columns to delete the same variables
# that are in the middle.
cols_to_pick <-
unique(c(sqp_env$short_estimate_variables, names(raw_data)))
} else {
cols_to_pick <- sqp_env$short_estimate_variables
}
final_df <- raw_data[row_to_pick, cols_to_pick]
final_df <- purrr::set_names(final_df, ~ gsub("prediction.", "", .x))
final_df <- tibble::add_column(final_df, question = var_name, .before = 1)
final_df
}
get_estimates(questions$id, all_columns = TRUE, authorized = FALSE) %>%
arrange(question)
sqp_data <-
get_estimates(questions$id, all_columns = TRUE) %>%
arrange(question)
sqp_data
sqp_sscore(sqp_data = sqp_data,
df = ess7es,
new_name = poltrst,
trstprl, trstplt, trstprt)
Quality <-
sqp_data %>%
sqp_sscore(df = ess7es, new_name = poltrst, trstprl, trstplt, trstprt) %>%
sqp_sscore(df = ess7es, new_name = serv, stfedu, stfhlth) %>%
sqp_sscore(df = ess7es, new_name = systmrsp, psppsgv, psppipl, ptcpplt)
Quality
Quality <-
Quality %>%
sqp_bind_metrics(agea, list(quality = 1)) %>%
sqp_bind_metrics(eisced, list(quality = 0.93))
Quality
variables_order <- c("poltrst",
"serv",
"systmrsp",
"ppltrst",
"polintr",
"stflife",
"stfeco",
"agea",
"eisced")
Quality <- Quality[match(variables_order, Quality$question), ]
ess7escorr <- ess7es %>% select(variables_order)
# Exploratory correlation matrix (in order of the columns in data frame):
original_corr_2 <- cor(ess7escorr, use = "complete.obs", method = "pearson")
original_corr_2
corr_q2 <-
sqp_correlate(x = ess7escorr,
diag_adj = Quality$quality,
use = "complete.obs",
method = "pearson")
corr_q2
#subtract the cmv from the observed correlation
corr_q2_cmv <-
sqp_cmv(x = corr_q2,
sqp_data = Quality,
stfeco, stflife)
corr_q2_cmv
cmv <-
Quality %>%
filter(question %in% c("stflife", "stfeco")) %>%
sqpr:::estimate_cmv()
corrected_corr <- corr_q2_cmv %>% select(-rowname) %>% as.matrix() %>% cov2cor()
corrected_corr
model<- "poltrst ~ ppltrst + stflife + polintr + stfeco + serv + systmrsp + agea + eisced"
# Model based on original correlation matrix
fit <-
sem(model,
sample.cov=original_corr_2,
sample.nobs= 1624)
# Model based on corrected correlation matrix
fit.corrected <-
sem(model,
sample.cov=corrected_corr,
sample.nobs= 1624)
coef_table <-
list(fit, fit.corrected) %>%
map(parameterestimates) %>%
map(~ filter(.x, lhs == "poltrst")) %>%
map(~ select(.x, rhs, est, ci.lower, ci.upper)) %>%
bind_rows() %>%
mutate(model = rep(c("original", "corrected"), each = 9))
coef_table %>%
ggplot(aes(rhs, est, colour = model)) +
geom_linerange(aes(ymin = ci.lower, ymax = ci.upper), position = position_dodge(width = 0.5)) +
geom_point(position = position_dodge(width = 0.5)) +
labs(x = "Predictors", y = "Estimated coefficients") +
theme_bw()
devtools::check()
devtools::install()
Sys.setenv(SQP_USER = 'cimentadaj@gmail.com'); Sys.setenv("SQP_PW" = "Lolasouno2"); Sys.setenv("ess_email" = "cimentadaj@gmail.com")
devtools::check()
devtools::check()
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.2, 0.4, 0.5, 0.5, 0.7),
validity = c(0.8, 0.1, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, rbinom(1000, 5, 0.6), simplify = FALSE),
paste0("V", 1:5))
)
sqp_df
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
sqp_data = sqp_df,
sqp_data = sqp_df
df = sample_data
new_name = new_sumscore
new_name = new_sumscore
new_name = "new_sumscore"
summary_name <- new_name
vars_names <- c("V1", "V2")
sqp_data <- sqp_reconstruct(sqp_data)
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in `df`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
vars_not_matched <- !vars_names %in% sqp_data[[1]]
if (any(vars_not_matched)) {
stop("One or more variables are not present in `sqp_data`: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
the_vars <- df[vars_names]
the_vars
if (!all(purrr::map_lgl(the_vars, is.numeric))) {
stop(paste0(vars_names, collapse = ", "), " must be numeric variables in `df`")
}
if (ncol(the_vars) < 2) stop("`df` must have at least two columns")
# Select the rows with only the selected variales
# for the sumscore
rows_to_pick <- sqp_data[[1]] %in% vars_names
sqp_scores <- sqp_data[rows_to_pick, sqp_env$sqp_columns]
if (anyNA(sqp_scores)) {
stop("`sqp_data` must have non-missing values at variable/s: ",
paste0(sqp_env$sqp_columns, collapse = ", "))
}
new_estimate <-
columns_sqp("quality", estimate_sscore(sqp_scores, the_vars, wt = wt))
wt = NULL
new_estimate <-
columns_sqp("quality", estimate_sscore(sqp_scores, the_vars, wt = wt))
new_estimate
new_estimate <-
columns_sqp("quality", estimate_sscore(sqp_scores, the_vars, wt = wt))
additional_rows <- generic_sqp(summary_name, new_estimate)
additional_rows
dplyr::bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
combined_matrix[c(correct_order, setdiff(names(combined_matrix), correct_order))]
additional_rows
rows_to_pick
rows_to_pick
logical()
length(logical())
rep(TRUE, length(rows_to_pick))
devtools::load_all()
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.2, 0.4, 0.5, 0.5, 0.7),
validity = c(0.8, 0.1, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, rbinom(1000, 5, 0.6), simplify = FALSE),
paste0("V", 1:5))
)
#' sqp_sscore(
#' sqp_data = sqp_df,
#' df = sample_data,
#' new_name = new_sumscore,
#' V3, V4
#' )
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4,
drop = FALSE
)
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4,
drop = TRUE
)
sqp_login()
test_that("get_estimates returns correct output", {
sqp_login()
set.seed(1231)
sqp_data <- get_estimates(sample(1:1000, row_n))
expect_is(sqp_data, "sqp")
expect_length(sqp_data, 4)
expect_true(nrow(sqp_data) == row_n)
expect_true(all(sqp_env$sqp_columns %in% names(sqp_data)))
})
library(testthat)
test_that("get_estimates returns correct output", {
sqp_login()
set.seed(1231)
sqp_data <- get_estimates(sample(1:1000, row_n))
expect_is(sqp_data, "sqp")
expect_length(sqp_data, 4)
expect_true(nrow(sqp_data) == row_n)
expect_true(all(sqp_env$sqp_columns %in% names(sqp_data)))
})
row_n <- 10
test_that("get_estimates returns correct output", {
sqp_login()
set.seed(1231)
sqp_data <- get_estimates(sample(1:1000, row_n))
expect_is(sqp_data, "sqp")
expect_length(sqp_data, 4)
expect_true(nrow(sqp_data) == row_n)
expect_true(all(sqp_env$sqp_columns %in% names(sqp_data)))
})
set.seed(231321)
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.2, 0.4, 0.5, 0.5, 0.7),
validity = c(0.2, 0.6, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, c(rbinom(1000, 5, 0.6), NA), simplify = FALSE),
paste0("V", 1:5))
)
test_that("sqp_sscore returns correct output", {
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
expect_s3_class(result, "data.frame")
expect_s3_class(result, "sqp")
expect_equal(nrow(result), 4)
expect_true(ncol(result) >= 3)
expect_is(result[[1]], "character")
})
test_that("sqp_sscore uses only unique variable names", {
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4, V4
)
expect_s3_class(result, "data.frame")
expect_s3_class(result, "sqp")
expect_equal(nrow(result), 4)
expect_true(ncol(result) >= 3)
expect_is(result[[1]], "character")
})
result <-
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4, V4,
drop = FALSE
)
result
sqp_df
expect_s3_class(result, "data.frame")
expect_s3_class(result, "sqp")
expect_equal(nrow(result), nrow(sqp_df) + 1)
expect_true(ncol(result) >= 3)
devtools::check()
?sqp_sscore
devtools::check()
devtools::load_all()
# Toy data
library(tibble)
sqp_df <-
tibble(question = paste0("V", 1:5),
quality = c(0.2, 0.3, 0.5, 0.6, 0.9),
reliability = c(0.2, 0.4, 0.5, 0.5, 0.7),
validity = c(0.8, 0.1, 0.6, 0.7, 0.8))
sqp_df <- structure(sqp_df, class = c(class(sqp_df), "sqp"))
sample_data <-
as_tibble(
setNames(
replicate(5, rbinom(1000, 5, 0.6), simplify = FALSE),
paste0("V", 1:5))
)
sqp_sscore(
sqp_data = sqp_df,
df = sample_data,
new_name = new_sumscore,
V3, V4
)
devtools::document()
devtools::document()
devtools::document()
