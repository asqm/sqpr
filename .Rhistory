library(usethis)
usethis::use_r("sqp_collect")
?use_data()
ex
ex <- readr::read_csv2("../sqp_analysis/SQPexport_20171230_2255.csv")
ex <- ex %>%     transmute(
question = tolower(`Question name`),
quality = as.numeric(`Quality (q2)`),
reliability = as.numeric(`Reliability (r2)`),
validity = as.numeric(`Validity (v2)`)
)
ex <- ex %>%     transmute(
question = tolower(`Question name`),
quality = as.numeric(`Quality (q2)`),
reliability = as.numeric(`Reliability (r2)`),
validity = as.numeric(`Validity (v2)`)
)
library(tidyverse)
ex <- ex %>%     transmute(
question = tolower(`Question name`),
quality = as.numeric(`Quality (q2)`),
reliability = as.numeric(`Reliability (r2)`),
validity = as.numeric(`Validity (v2)`)
)
ex
use_data(ex)
use_r("sqp_construct")
use_r("sqp_sscore")
environment()
top_env <- new.env(parent = emptyenv())
use_r("sqp_rbind_metrics")
devtools::load_all()
sqp_collect()
use_package("readr")
devtools::load_all()
sqp_collect()
devtools::load_all()
sqp_collect()
?readr::read_rds
?load
devtools::load_all()
ls()
sqp_collect()
devtools::load_all()
sqp_collect()
sqp_collect()
devtools::load_all()
sqp_collect()
load("data/ex.rda")
ls()
ex
devtools::load_all()
ls()
file.copy("../sqp_analysis/SQPexport_20171230_2255.csv", "data/")
devtools::load_all()
sqp_collect()
devtools::load_all()
sqp_collect()
library(usethis)
use_package("purrr")
use_package("dplyr")
%in%
?%in%
?`%in%`
?stop
sqp_data <- sqp_collect()
sqp_data
sqp_data <- sqp_collect()
summary_name <- "polit"
vars_names <- c("ppltrst", "polintr")
# Check all variables present in df
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in df: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
df <- ess::ess_rounds(7, "cimentadaj@gmail.com")
# Check all variables present in df
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in df: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
# Check all variables present in sqp_data
vars_not_matched <- !vars_names %in% sqp_data[[1]]
if (any(vars_not_matched)) {
stop("One or more variables are not present in sqp_data: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
the_vars <- df[vars_names]
# Check all variables are numeric and there are at least two columns in the df data
if (!all(purrr::map_lgl(the_vars, is.numeric))) stop("All variables must be numeric")
if (ncol(the_vars) < 2) stop("df must have at least two columns")
# Check SQP data has correct class and formats
check_sqp_data(sqp_data)
# Select the rows with only the selected variales
# for the sumscore
rows_to_pick <- sqp_data[[1]] %in% vars_names
sqp_scores <- sqp_data[rows_to_pick, 2, drop = TRUE]
devtools::load_all()
columns_sqp("quality", 10)
devtools::load_all()
columns_sqp("quality", 10)
devtools::load_all()
columns_sqp("quality", 10)
sqp_data <- sqp_collect()
df <- ess::ess_rounds(7, "cimentadaj@gmail.com")
summary_name <- "polit"
vars_names <- c("ppltrst", "polintr")
# Turn all variables into a list and delete the 'list'
# from the new character vector
vars_names <- as.character(substitute(list(...)))[-1]
summary_name <- as.character(substitute(new_name))
# Check all variables present in df
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in df: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
summary_name <- "polit"
vars_names <- c("ppltrst", "polintr")
# Check all variables present in df
vars_not_matched <- !vars_names %in% names(df)
if (any(vars_not_matched)) {
stop("One or more variables are not present in df: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
# Check all variables present in sqp_data
vars_not_matched <- !vars_names %in% sqp_data[[1]]
if (any(vars_not_matched)) {
stop("One or more variables are not present in sqp_data: ",
paste0(vars_names[vars_not_matched], collapse = ", "),
call. = FALSE)
}
the_vars <- df[vars_names]
# Check all variables are numeric and there are at least two columns in the df data
if (!all(purrr::map_lgl(the_vars, is.numeric))) stop("All variables must be numeric")
if (ncol(the_vars) < 2) stop("df must have at least two columns")
# Check SQP data has correct class and formats
check_sqp_data(sqp_data)
# Select the rows with only the selected variales
# for the sumscore
rows_to_pick <- sqp_data[[1]] %in% vars_names
sqp_scores <- sqp_data[rows_to_pick, 2, drop = TRUE]
estimate_sumscore(sqp_scores, the_vars, vars_names)
# Check the SQP data
check_sqp_data <- function(sqp_data) {
stopifnot(is.data.frame(sqp_data))
first_character <- is.character(sqp_data[[1]])
all_numeric <- all(purrr::map_lgl(sqp_data[-1], is.numeric))
# Check all variables are numeric in the sqp data
if(!first_character | !all_numeric) {
stop("The first column must be a character vector containing the question names and all other columns must be numeric")
}
}
# This is not supposed to be used in isolation.
# Rather with measurement quality as a wrapper
# because it checks all of the arguments are in
# the correct format, etc..
estimate_sumscore <- function(sqp_data, df, vars_names) {
# Calculate the sum score and it's variance
var_sumscore <- stats::var(rowSums(df, na.rm = TRUE), na.rm = TRUE)
# Calculat variable of each of the selected variables
var_othervars <- purrr::map_dbl(df, var, na.rm = TRUE)
# Each sqp score is subtracted a 1 and multiplied
# by it's corresponding var_* variables
adj_sqp <- (1 - sqp_data) *  var_othervars
# This new vector is summed and divided by the variance of the sumscore
# and 1 is subtracted from the final result
final_result <- 1 - sum(adj_sqp) / var_sumscore
final_result
}
estimate_sumscore(sqp_scores, the_vars, vars_names)
columns_sqp("quality", estimate_sumscore(sqp_scores, the_vars, vars_names))
new_estimate <-
columns_sqp("quality", estimate_sumscore(sqp_scores, the_vars, vars_names))
generic_sqp(summary_name, new_estimate)
# Bind the unselected questions with the new sumscore
combined_matrix <- bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
combined_matrix
combined_matrix <- dplyr::bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
additional_rows <- generic_sqp(summary_name, new_estimate)
# Bind the unselected questions with the new sumscore
combined_matrix <- dplyr::bind_rows(sqp_data[!rows_to_pick, ], additional_rows)
combined_matrix
devtools::install()
devtools::install()
sqpr::sqp_collect()
unloadNamespace("spr")
sqp_raw <- readr::read_csv2("data/SQPexport_20171230_2255.csv")
sqp_data_fin <-
dplyr::transmute(
sqp_raw,
question = tolower(`Question name`),
quality = as.numeric(`Quality (q2)`),
reliability = as.numeric(`Reliability (r2)`),
validity = as.numeric(`Validity (v2)`)
)
sqp_data_fin
sqp_raw <- readr::read_csv2("data/SQPexport_20171230_2255.csv")
sqp_raw
sqp_data_fin <-
dplyr::transmute(
sqp_raw,
question = tolower(`Question name`),
quality = as.numeric(`Quality (q2)`),
reliability = as.numeric(`Reliability (r2)`),
validity = as.numeric(`Validity (v2)`)
)
sqp_data_fin
usethis::use_data(sqp_data_fin)
?usethis::use_data
data("sqp_data_fin")
ls()
sqp_data_fin
devtools::check()
usethis::use_package("stats")
devtools::check()
usethis::use_roxygen_md()
?usethis::use_roxygen_md()
?usethis::use_roxygen_md
devtools::load_all()
sqp_collect()
devtools::load_all(".")
ls()
devtools::load_all(".")
ls()
devtools::install(".")
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::install(".")
sqpr::construct_sqp("quality", 2)
sqpr::construct_sqp("plt", list(quality = 2))
sqpr::construct_sqp("plt", list(quality = 2))
sqpr::construct_sqp("plt", list(quality = 2))
sqpr::construct_sqp("plt", list(quality = 2))
c("hey" = 1)
list(c("hey" = 1))
list(c("hey" = 1))
unlist(list(c("hey" = 1)))
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("question_name must have only one question")
if (!is.list(metrics)) metrics <- purrr::set_names(list(metrics), names(metrics))
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric) {
stop("Metrics must be a named list or named numeric vector")
}
if (length(names(metrics)) != length(unlist(metrics))) {
stop("Metrics must contain only one element per name")
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp <- function(question_name, metrics) {
question <- as.character(substitute(question_name))
construct_sqp_(question, metrics)
}
construct_sqp(prt, list(quality = 1))
# unexported
# Specify columns that should be in the SQP data and
# replacements
# returns a named list with the replacements
# added
columns_sqp <- function(columns_to_fill, replacement) {
if (!all(columns_to_fill %in% top_env$sqp_columns)) {
stop("One or more of the specified columns don't match the SQP column names",
call. = FALSE)
}
# sqp_columns is a global variable defining
# the columns that SQP needs to have
num_cols <- length(top_env$sqp_columns)
empty_cols <- purrr::set_names(purrr::rerun(num_cols, NA), top_env$sqp_columns)
# iterate through each column/replacement and fill
# out the empty list
for (some_cols in seq_along(columns_to_fill)) {
chosen_col <- columns_to_fill[some_cols]
empty_cols[[chosen_col]] <- replacement[some_cols]
}
filled_cols <- empty_cols
filled_cols
}
# unexported
# Create a tibble with the question name and
# the sqp matrics. Returns the tibble
generic_sqp <- function(question_name, sqp_metrics) {
stopifnot(!is.null(names(sqp_metrics)), is.list(sqp_metrics))
dplyr::as_tibble(c(question = question_name, sqp_metrics))
}
# Variables to pick from the sqp remote data
# and with which to create sqp tables
top_env <- new.env(parent = emptyenv())
top_env$sqp_columns <- c("quality", "reliability", "validity")
construct_sqp(prt, list(quality = 1))
construct_sqp(prt, c(quality = 1))
construct_sqp(prt, c(quality = c(1, 2)))
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("question_name must have only one question")
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric) {
stop("Metrics must be a named list or named numeric vector")
}
if (!is.list(metrics)) metrics <- purrr::set_names(list(metrics), names(metrics))
if (length(names(metrics)) != length(unlist(metrics))) {
stop("Metrics must contain only one element per name")
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
construct_sqp(prt, c(quality = c(1, 2)))
metrics <- c(quality = c(2, 3))
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
named
numeric
if (!named | !numeric) {
stop("Metrics must be a named list or named numeric vector")
}
unlist(metrics)
length(unlist(metrics))
names(metrics)
metrics
metrics
metrics <- c(quality = 1)
metrics
metrics <- c(quality = c(1, 2))
metrics
metrics <- list(quality = c(1, 2))
metrics
my_g <- function(p) {
p
}
my_fun <- function(x) {
my_g(x)
}
my_g <- function(p) {
p
}
my_fun(list(quality = 1))
my_fun(c(quality = 1))
my_g <- function(p) {
m <- substitute(p)
m
}
my_fun(c(quality = 1))
c(quality = c(1, 2))
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("question_name must have only one question")
is_list <- is.list(metrics)
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric | !is_list) {
stop("Metrics must be a named numeric list")
}
if (length(names(metrics)) != length(unlist(metrics))) {
stop("Metrics must contain only one element per name")
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
construct_sqp(prt, c(quality = c(1, 2)))
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("question_name must have only one question")
is_list <- is.list(metrics)
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric | !is_list) {
stop("Metrics must be a named numeric list",
call. = FALSE)
}
if (length(names(metrics)) != length(unlist(metrics))) {
stop("Metrics must contain only one element per name",
call. = FALSE)
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
construct_sqp(prt, c(quality = c(1, 2)))
#' Title
#'
#' @param question_name
#' @param metrics
#'
#' @return
#' @export
#'
#' @examples
construct_sqp_ <- function(question_name, metrics) {
question <- question_name
if (length(question) > 1) stop("question_name must have only one question")
is_list <- is.list(metrics)
named <- !is.null(names(metrics))
numeric <- is.numeric(unlist(metrics))
if (!named | !numeric | !is_list) {
stop("metrics must be a named numeric list",
call. = FALSE)
}
if (length(names(metrics)) != length(unlist(metrics))) {
stop("metrics must contain only one element per name",
call. = FALSE)
}
sqp_metrics <- columns_sqp(names(metrics), unlist(metrics))
generic_sqp(question, sqp_metrics)
}
construct_sqp(prt, c(quality = c(1, 2)))
construct_sqp(prt, list(quality = c(1, 2)))
construct_sqp(prt, list(quality = c(1)))
construct_sqp(prt, list(quality = c(1), hey = 2))
# unexported
# Specify columns that should be in the SQP data and
# replacements
# returns a named list with the replacements
# added
columns_sqp <- function(columns_to_fill, replacement) {
if (!all(columns_to_fill %in% top_env$sqp_columns)) {
stop("One or more of the specified metrics don't match the SQP column names",
call. = FALSE)
}
# sqp_columns is a global variable defining
# the columns that SQP needs to have
num_cols <- length(top_env$sqp_columns)
empty_cols <- purrr::set_names(purrr::rerun(num_cols, NA), top_env$sqp_columns)
# iterate through each column/replacement and fill
# out the empty list
for (some_cols in seq_along(columns_to_fill)) {
chosen_col <- columns_to_fill[some_cols]
empty_cols[[chosen_col]] <- replacement[some_cols]
}
filled_cols <- empty_cols
filled_cols
}
construct_sqp(prt, list(quality = c(1), hey = 2))
construct_sqp(prt, list(quality = c(1), hey = c(2, 2)))
construct_sqp(prt, list(quality = c(1), reliability = c(2, 2)))
construct_sqp(prt, list(quality = c(1), reliability = c(2)))
devtools::document()
# Variables to pick from the sqp remote data
# and with which to create sqp tables
top_env <- new.env(parent = emptyenv())
pl <- list()
pl$a <- 1
pl
construct_sqp(prt, list(quality = c(1), reliability = c(2)))
construct_sqp(prt, list(quality = 1, reliability = c2))
construct_sqp(prt, list(quality = 1, reliability = 2))
devtools::check()
devtools::test()
devtools::document()
usethis::use_test()
